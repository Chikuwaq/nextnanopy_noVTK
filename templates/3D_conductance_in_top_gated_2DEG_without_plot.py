#***************************************************************************!
# (c) nextnano GmbH                                                         !
#                                                                           !
# This is an input file for the following tutorial:                         !
#   - top-gated 2D electron gases structure                                 !
#                                                                           !
#***************************************************************************!

import nextnanopy as nn                                     # package necessary to read output results from nextnano++
import numpy as np                                          # package with linear algebra (always important)
import kwant as kw                                          # Kwant - you know about it already! (for quantum transport)
from scipy.interpolate import interp2d                      # package with algorithms (here for interpolation only)
import matplotlib as mpl
import matplotlib.pyplot as plt

#---------------------------------------------------------------------------#
# path where the results of nextnano++ are stored                           #
#---------------------------------------------------------------------------#

# EDIT THE PATH TO YOUR OUTPUT FOLDER                                                                           
# EDIT THE PATH TO YOUR OUTPUT FOLDER
# EDIT THE PATH TO YOUR OUTPUT FOLDER                                                                                       
path_extracted_potential = r'C:\...\3D_conductance_in_top_gated_2DEG_nnp'
# EDIT THE PATH TO YOUR OUTPUT FOLDER
# EDIT THE PATH TO YOUR OUTPUT FOLDER    
# EDIT THE PATH TO YOUR OUTPUT FOLDER

# simulations in nextnano++

number_of_bias = 101                                        # number of input files generated by nextnano++ 
Gate_Volt_min = -1.5                                        # voltage on the top gate for the first element of the sweep
Gate_Volt_max = 0.0                                         # voltage on the top gate for the last element of the sweep

#---------------------------------------------------------------------------#
# constants                                                                 #
#---------------------------------------------------------------------------#

e    = 1.602e-19                                            # electron charge (C)
hbar = 6.626e-34/2/np.pi                                    # Dirac constant (Js)
h    = 6.626e-34                                            # Planck constant (Js)
nm   = 1e-9                                                 # 1 nanometer (m)
        
ms = 0.067 * 9.109e-31                                      # an effective mass of electrons in 2DEG 
a = 1                                                       # lattice constant of the tight-binding system (nm)
T = hbar*hbar/2/nm/nm/ms/e                                  # constant to convert from eV (output of nn++) to kwant energy unit

#---------------------------------------------------------------------------#
# parameters                                                                #
#---------------------------------------------------------------------------#

left = -200                                                 # left limit of the scattering region (nm)
right = 200                                                 # right limit of the scattering region (nm)
    
bottom = -200                                               # lower limit of the scattering region (nm)
top = 200                                                   # upper limit of the scattering region (nm)
    
def qpc_potential(site):                                    # potential in the scattering region
    x, y = site.pos 
        
    return -interpolated_potential(x,y)[0]/T    
    
    
def lead_potential(site):                                   # potential in the left lead
    x, y = site.pos 
        
    return -interpolated_potential(left,y)[0]/T     
       
def lead_potential2(site):                                  # potential in the right lead
    x, y = site.pos 
    
    return -interpolated_potential(right,y)[0]/T    
    
def make_lead_input(pot, t=1):                              # defining the right lead
    
    def onsite(*args):                                      # return the matrix element of a given site (A_i,j)
        return 4 * t - pot(*args)   
        
    def hopping(*args):                                     # return the hopping between two given sites (T_i,j,i+1,j)
        return -t 

    syst = kw.Builder(kw.TranslationalSymmetry([-a, 0]))    # specify a translational symmetry 


    syst[(lat(left//a, y) for y in np.arange(bottom//a+1,top//a,1))] = onsite # define the matrix element of each site 
    syst[lat.neighbors()] = hopping                         # define the hopping parameters between closest neighbours  
    
    return syst

def make_lead_output(pot, t=1):                             # defining the left lead
   
    def onsite(*args):                                      # return the matrix element of a given site (A_i,j)
        return 4 * t - pot(*args)
    
    def hopping(*args):                                     # return the hopping between two given sites (T_i,j,i+1,j)
        return -t 

    syst = kw.Builder(kw.TranslationalSymmetry([a, 0]))     # specifiy a translational symmetry 
    
    syst[(lat(right//a, y) for y in np.arange(bottom//a+1,top//a,1))] = onsite # define the matrix element of each site
    syst[lat.neighbors()] = hopping                         # define the hopping parameters between closest neighbours
    
    return syst

def make_system(pot1,pot2,pot3, t=1):                       # define the scattering region
    
    def onsite(*args):
        return 4 * t - pot1(*args)
    
    def hopping(*args):
        return -t

    # Construct the scattering region.
    
    # 1st step - creating an “empty” tight binding system
    sr = kw.Builder()
    
    # 2st step - setting matrix elements
    sr[(lat(x, y) for x in np.arange(left//a+1,right//a,1) for y in np.arange(bottom//a+1,top//a,1))] = onsite
    
    # 2st step - setting hoppings
    sr[lat.neighbors()] = hopping

    # 3rd step - Construct the leads and attach them to the scattering region.
    lead = make_lead_input(pot2, t)
    sr.attach_lead(lead)

    lead3 = make_lead_output(pot3, t)
    sr.attach_lead(lead3)

    return sr

# +++++ Reading, Preparing, and Simulationg +++++ #
# +++++++++++++++++++++++++++++++++++++++++++++++ #

conductance = []

print('Iteration:', end = ' ')

for k in range(number_of_bias):
    print(str(k), end = ' ')
    
    # reading 
    
    extracted_potential = nn.DataFile(path_extracted_potential + fr'\bias_{str(k).zfill(5)}\bandedges_2d_2deg_slice.fld',product='nextnano++')
    x = extracted_potential.coords['x'].value
    y = extracted_potential.coords['y'].value
    potential = extracted_potential.variables['Gamma'].value

    # preparing
    
    interpolated_potential=interp2d(x, y, potential.T)
    lat = kw.lattice.square(a)
    qpc = make_system(qpc_potential, lead_potential, lead_potential2, t=1/a**2)
    
    fqpc = qpc.finalized()  
    
    # simulating
    
    smatrix = kw.smatrix(fqpc, 0, in_leads = [0])
    conductance.append(smatrix.conductance(1,0))
     
# +++++ Plotting +++++ #
# ++++++++++++++++++++ #

### make large plots and labels
mpl.rc('figure', figsize=(8, 6))
mpl.rc('axes', labelsize=15, titlesize=20)
mpl.rc('xtick', labelsize=15)
mpl.rc('ytick', labelsize=15)

V=np.linspace(Gate_Volt_min, Gate_Volt_max, number_of_bias)
plt.plot(V, conductance, color = 'red')
plt.xlabel('$V_{gate} (V)$')
plt.ylabel('Conductance ($2e^2/h$)')
plt.title('Conductance between lead 0 to lead 1\n')
plt.savefig('Conductance lead 0 to 1.png')
plt.show()

